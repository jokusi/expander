-- base

defuncts: head tail init last take drop <=< kfold
preds:	P Q R
fovars:	x y z s s' n
hovars:	F G P Q R

axioms:

[x]++s == x:s &
[]++s == s &
s++[] == s &
(x:s)++s' == x:s++s' &

head$x:s == x &
tail$x:s == s &

init[x] == [] &
init$x:y:s == x:init$y:s &
init(s)++[last$s] == s &

last[x] == x &
last$x:y:s == last$y:s &

take(0)$s == [] &
take(n)$x:s == x:take(n-1)$s &

drop(0)$s == s &
drop(n)$x:s == drop(n-1)$s &

length$x:s == length(s)+1 &
length$init$x:s == length$s &

map(F)$x:s == F(x):map(F)$s &

G<=<F == concat.map(G).F &       		-- Kleisli composition for [ ]

kfold(F) == foldl$fun((s,x),concat$map(F$x)$s) &       -- Kleisli fold for [ ]

x+0 == x & x+0.0 == x &
0+x == x & 0.0+x == x &

x-0 == x & x-0.0 == x &
0-x == -x & 0.0-x == -x &

x*0 == 0 & x*0.0 == 0 &
0*x == 0 & 0.0*x == 0 &
x*1 == x & x*1.0 == x &
1*x == x & 1.0*x == x &

0/x == 0 & 0.0/x == 0 &
x/1 == x & x/1.0 == x &

x**0 == 1 & x**0.0 == 1 &
0**x == 0 & 0.0**x == 0 &
x**1 == x & x**1.0 == x &
1**x == 1 & 1.0**x == 1 &

([] = x:s <==> False) &
(x:s = [] <==> False) &

([] =/= x:s <==> True) &
(x:s =/= [] <==> True) &

(x <= x <==> True) &
(x >= x <==> True) &

(x < x <==> False) &
(x < suc$x <==> True) &

(x > x <==> False) &
(suc$x > x <==> True) &
(suc(x)-y > x-y <==> True) &
(x-y > x-suc(y) <==> True) &

(x `in` [] <==> False) &
(x `NOTin` [] <==> True) 

{-
x+suc(y) == suc(x+y) &
suc(x)+y == suc(x+y) &
suc(x)-suc(y) == x-y &
x*suc(y) == x+(x*y) & 
suc(x)*y == (x*y)+y & 
x**suc(y) == x*(x**y) &

(x `in` y:s <==> x = y | x `in` s) &
(x `NOTin` y:s <==> x =/= y & x `NOTin` s) 
-}
