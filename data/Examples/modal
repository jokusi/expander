-- modal

defuncts: noProcs procs states labels atoms valid
preds:    X sat satL -> true false not \/ /\ `then` or and alloutL
          allanytrans allanytransL EX XE <> >< EF AF FE FA `EU` `AU`
copreds:  ~ eqstate AX XA # ## AG EG GE GA `EW` `AW` `ER` `AR`
fovars:   s s' st st' lab at
hovars:   X

axioms:

   procs == [0..noProcs-1]    -- used in many specifications that import modal

-- state equivalence relations
 
 & (eqstate <==> NU X.rel((st,st'),out$st=out$st' & 
			           alloutL(st,st') &
				   allanytrans(X)(st,st') &
				   allanytrans(X)(st',st) &
				   allanytransL(X)(st,st') &
				   allanytransL(X)(st',st)))

 & (st ~ st' ===> out$st=out$st' & 
		  alloutL(st,st') &
		  allanytrans(~)(st,st') & allanytrans(~)(st',st) &
		  allanytransL(~)(st,st') & allanytransL(~)(st',st))

 & (alloutL(st,st') <==> all(rel(lab,outL(st)$lab=outL(st')$lab))$labels)

 & (allanytrans(P)(st,st')  <==> allany(P)(trans$st,trans$st'))
 & (allanytransL(P)(st,st') <==> all(rel(lab,allany(P)(transL(st)$lab,
						       transL(st')$lab)))
 				     $labels)

-- simplification of first-order state formulas

 & (sat(at)$st <==> at `in` out$st)
 & (satL(at,lab)$st <==> at `in` outL(st)$lab)

 & (EX(P)$st <==> any(P)$concat$trans(st):map(transL$st)$labels)
 & (AX(P)$st <==> all(P)$concat$trans(st):map(transL$st)$labels)
 & ((lab<>P)$st <==> any(P)$transL(st)$lab)
 & ((lab#P)$st <==> all(P)$transL(st)$lab)

 & (XE(P)$st <==> any(P)$parents$st)
 & (XA(P)$st <==> all(P)$parents$st)
 & ((lab><P)$st <==> any(P)$parentsL(st)$lab)
 & ((lab##P)$st <==> all(P)$parentsL(st)$lab)

 & (true$st <==> True)
 & (false$st <==> False)
 & (not(P)$st <==> Not(P$st))
 & ((P/\Q)$st <==> P$st & Q$st)
 & ((P\/Q)$st <==> P$st | Q$st)
 & ((P`then`Q)$st <==> (P$st ==> Q$st))

-- simplification of second-order state formulas

 & (or <==> foldl(\/)$false)
 & (and <==> foldl(/\)$true)

 & (EF$P <==> MU X.(P\/EX$X))		     -- forward finally on some path
 & (FE$P <==> MU X.(P\/XE$X))		     -- backwards finally on some path
 & (AF$P <==> MU X.(P\/(AX(X)/\EX$true)))    -- forward finally on all paths 	
 & (FA$P <==> MU X.(P\/(XA(X)/\XE$true)))    -- backwards finally on all paths 	
 & (EG$P <==> NU X.(P/\(EX(X)\/AX$false)))   -- forward generally on some path
 & (GE$P <==> NU X.(P/\(XE(X)\/XA$false)))   -- backwards generally on some path
 & (AG$P <==> NU X.(P/\AX$X))		     -- forward generally on all paths
 & (GA$P <==> NU X.(P/\XA$X))		     -- backwards generally on all paths

 & ((P`EU`Q) <==> MU X.(Q\/(P/\EX$X)))	     -- until
 & ((P`AU`Q) <==> MU X.(Q\/(P/\AX$X)))		
 & ((P`EW`Q) <==> NU X.(Q\/(P/\EX$X)))       -- weak until
 & ((P`AW`Q) <==> NU X.(Q\/(P/\AX$X)))
 & ((P`ER`Q) <==> NU X.(Q/\(P\/EX$X)))       -- release
 & ((P`AR`Q) <==> NU X.(Q/\(P\/AX$X)))

-- narrowing of first-order state formulas

 & (EF(P)$st <=== P$st | EX(EF$P)$st)	     -- forward finally on some path  	   
 & (AG(P)$st ===> P$st & AX(AG$P)$st)	     -- forward generally on all paths
 & (AF(P)$st <=== P$st | AX(AF$P)$st & EX(true)$st)	
					     -- forward finally on all paths   	
 & (EG(P)$st ===> P$st & (EX(EG$P)$st | AX(false)$st)) 	
					     -- forward generally on some path
 & (FE(P)$st <=== P$st | XE(FE$P)$st)	     -- backwards finally on some path	 
 & (GA(P)$st ===> P$st & XA(GA$P)$st)	     -- backwards generally on all paths
 & (FA(P)$st <=== P$st | XA(FA$P)$st & XE(true)$st)		
					     -- backwards finally on all paths
 & (GE(P)$st ===> P$st & (XE(GE$P)$st | XA(false)$st)) 	
					     -- backwards generally on some path
	
 & ((P`EU`Q)$st <=== Q$st | P$st & EX(P`EU`Q)$st)	-- until
 & ((P`AU`Q)$st <=== Q$st | P$st & AX(P`AU`Q)$st)		
 & ((P`EW`Q)$st ===> Q$st | P$st & EX(P`EW`Q)$st)	-- weak until
 & ((P`AW`Q)$st ===> Q$st | P$st & AX(P`AW`Q)$st)	
 & ((P`ER`Q)$st ===> Q$st & (P$st | EX(P`ER`Q)$st))	-- release
 & ((P`AR`Q)$st ===> Q$st & (P$st | AX(P`AR`Q)$st))
